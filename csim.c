/* 
 * Cache Lab 2 (Part A)
 * Author: Aiden Vandekerckhove
 * Date: 4/23/23
 * csim.c
 *
 * A simulated cache system program. This program allows you to simulate the cache performance   
 * loading, storing, and modifying data by running a memory trace file generated by Valgrind.
 * You can dynamical specify the dimensions of the cache structure like the number of sets (S), the
 * block size (B), and the number of cache lines per set (E) to understand how a memory trace performs
 * for diffrent cache structures.
 *
 * Note that there no actual data is being cached, it is simply a performance simulation tool to
 * understand the number of hits, misses, and evictions.
 * For details on usage run the compiled program with the help flag (-h), or enable verbose mode (-v)
 * to display the trace info while running.
 *
 * For my implementation, I took some elements of inspiration from the example provided in class, but
 * a put a lot of my own spin on it to make improvements using some of the feedback you mentioned, my 
 * own knowledge, and some of the ideas I used in lab1. I tried to avoid looking at the example too much
 * and typed everything manually. Especially for the actual cache accessing logic I avoided looking at the
 * example and went from scratch, and I think I'm pretty happy with how it turned out.
 */

#include "cachelab.h"
#include <time.h>
#include <getopt.h>
#include <stdlib.h>
#include <stdio.h>

#define LINE_SIZE 100

// A structure to represent one of the cache lines in each set.
typedef struct entry {
    int valid;
    long tag;
    clock_t lastAccess; // Store last access time for LRU replacement policy.
} cache_line;

typedef cache_line* cache_set;
typedef cache_set* cache_table;


cache_table cache; // Global cache structure table.

int hits, misses, evictions; // Performance counters.
int s = 0, E = 0, b = 0; // Cache structure parameters.
char *traceFile = NULL;
int verbose = 0; // Debug mode to print trace info (default false).

// Helper function to display the help usage details in command line application:
void showHelp() {
    printf("Usage: ./csim [-hv] -s <num> -E <num> -b <num> -t <file>\n\n"

            "Options:\n"
            "   -h         Optional help flag that prints this usage info message.\n"
            "   -v         Optional verbose flag that displays trace info.\n"
            "   -s <num>   Number of set index bits (S = 2^s is the number of sets)\n"
            "   -E <num>   Associativity (number of lines per set).\n"
            "   -b <num>   Number of block offset bits (B = 2^b is the block size).\n"
            "   -t <file>  Name of the valgrind trace to replay.\n\n"

            "Examples:\n"
            "   linux>  ./csim -s 4 -E 1 -b 4 -t traces/yi.trace\n"
            "   linux>  ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace\n\n");
}

// Parse and load in program parameters:
void setPrams(int argc, char *argv[]) {
    int c;
    while ((c = getopt(argc, argv, "s:E:b:t:vh")) != -1) {
        switch (c) {
            case 's': // Specify the number of set index bits.
                s = atoi(optarg);
                break;
            case 'E': // Specify the number of lines per set.
                E = atoi(optarg);
                break;
            case 'b': // specify the number of block offset bits.
                b = atoi(optarg);
                break;
            case 't': // Specify the memory trace file to simulate.
                traceFile = optarg;
                break;
            case 'v':
                verbose = 1; // Set verbose debug mode true.
                break;
            case 'h':
                showHelp();
                exit(0);
            default: // Show usage and exit for invalid flag.
                showHelp();
                exit(1);
        }
    }

    // Ensure required flags are set with valid arguments, otherwise exit:
    if (s <= 0 || E <= 0 || b <= 0 || traceFile == NULL) {
        printf("Invalid arguments!\n");
        showHelp();
        exit(1);
    }
}


// Dynamically allocate memory space for the cache table structure.
void initCache() {
    int numSets = 1 << s; // Calculate the number of sets 2^s.
    // Allocate pointer array to each set row in the cache.
    cache = (cache_set *) malloc(sizeof(cache_set) * numSets);

    // Allocate space for the set row and initialize the empty cache lines:
    for (int setIndex = 0; setIndex < numSets; setIndex++) {
        cache[setIndex] = (cache_line *) malloc(sizeof(cache_line) * E);

        for (int lineIndex = 0; lineIndex < E; lineIndex++) {
            cache[setIndex][lineIndex] = (cache_line) {0, 0, 0};
        }
    }
}

// Free allocated cache memory space (in reverse, set rows then the set pointers array).
void freeCache() {
    int numSets = 1 << s; // Calculate the number of sets 2^s.
    for (int setIndex = 0; setIndex < numSets; setIndex++) {
        free(cache[setIndex]);
    }

    free(cache);
}


// Extract the set index from the memory address.
int getSet(void *address) {
    return (((long) address) >> b) & ((1 << s) - 1);
}

// Extract the tag from the memory address.
long getTag(void *address) {
    return ((long)address >> (s + b));
}


void accessCache(void *address, int size) {
    int setIndex = getSet(address);
    int lineIndex;
    long tag = getTag(address);

    int empty = -1; // Track empty cache line in case of miss (default -1 for no empty found).
    int LRU = 0; // Track the least recently used cache line for replacment policy.
    clock_t oldestAccessTime = cache[setIndex][0].lastAccess;

    // Search each cache line in the set to check if the data address is in the cache:
    for (lineIndex = 0; lineIndex < E; lineIndex++) {
        if (cache[setIndex][lineIndex].tag == tag) {
            if (cache[setIndex][lineIndex].valid) {
                // If the cache line has a matching tag and is valid then it's a hit and we update the last access.
                cache[setIndex][lineIndex].lastAccess = clock();

                hits++;
                if (verbose) { printf("hit "); } // Verbose mode show hit.
            } else {
                // If the cache line has a matching tag but is invalid then it's a miss so we set valid and update the last access.
                cache[setIndex][lineIndex].valid = 1;
                cache[setIndex][lineIndex].lastAccess = clock();

                misses++;
                if (verbose) { printf("miss "); } // Verbose mode show miss.
            }

            return; // End accessCache call because cache line has been set/updated. 
        }

        // Track the first empty cache we encounter so it can be found quicker.
        if (!cache[setIndex][lineIndex].valid && empty == -1) { empty = lineIndex; }
        // Check and update least recently used cache line.
        if (cache[setIndex][lineIndex].lastAccess < oldestAccessTime) {
            oldestAccessTime = cache[setIndex][lineIndex].lastAccess;
            LRU = lineIndex;
        }
    }

    misses++; // miss, address was not found in cache.
    if (verbose) { printf("miss "); } // Verbose mode show miss.

    // Check if there was an empty spot, or if we need to evict the LRU cache line:
    if (empty != -1) {
        lineIndex = empty;
    } else {
        lineIndex = LRU;

        evictions++;
        if (verbose) { printf("eviction "); } // Verbose mode show eviction.
    }
    cache[setIndex][lineIndex] = (cache_line) {1, tag, clock()}; // Add address to cache.
}


// Parse and run simulated cache operations from the trace file.
void runTraceSimulation() {
    FILE *fp = fopen(traceFile, "r");
    if (fp == NULL) { // Ensure file exists and opens properly.
        printf("Trace file not found!");
        exit(1);
    }
    
    char buffer[LINE_SIZE];
    char operation;
    void *address;
    int size;

    // Read each line and run cache operation till end of trace file:
    while (fgets(buffer, LINE_SIZE, fp) != NULL) {
        sscanf(buffer, " %c %p,%d", &operation, &address, &size); // Parse trace line to extract cache operation parameteres.
        if (operation == 'I') { continue; } // Ignore instruction load operations.

        if (verbose) { // Verbose debug mode prints trace.
            printf("\n%c %p,%d ", operation, address, size);
        }

        // Run the correct cache operations:
        if (operation == 'L' || operation == 'S') { // Store and load share outcomes so implementation is the same. 
            accessCache(address, size);
        } else if (operation == 'M') { // Modify (load store) is the same outcome as a load operation with a hit for store.
            accessCache(address, size);

            hits++; // Guaranteed hit for store operation.
            if (verbose) { printf("hit "); } // Verbose mode show store hit.
        }
    }

    fclose(fp); // Close file when finished.
}


int main(int argc, char *argv[]) {
    setPrams(argc, argv);
    initCache();
    runTraceSimulation();
    printf("\n");
    freeCache();

    // Submit and display cache performance results.
    printSummary(hits, misses, evictions);
    return 0;
}
